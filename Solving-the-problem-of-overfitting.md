## オーバーフィッティングとは

これまで，データセットに対して最もフィットするn次の関数を求めるために，

最適なθを求めるアルゴリズムについて考えてきた．

しかし，全てのデータセットを通るn次の関数を求めたとしても，

以下のように，任意のベクトルxに対するちゃんとした値を返してくれるとは限らない，

![clipboard.png](inkdrop://file:B1q-MMLRM)

左の例では，あまりデータセットに対して，関数はフィットしてない．(アンダーフィッティング，ハイバイアス)

関数が単純で，参考となるパラメータが少ない場合に起こる．

真ん中の例では，1次元ベクトルを増やして，2次関数として仮説関数を当てはめた例である．

左図よりかはフィットしている．

最後に右図の例．これはデータセットに対して5次関数として表現された仮説関数である．

全てのデータセットを通る関数ではあるが，データセットに対して最適にフィットしているとは言えない．(オーバーフィッティング)

(= 例えば，任意の家の広さに対して，最適な家の価格を算出できない.)

このように，次数を増やせば増やすほど，データセットに対して目的関数は通るが，

すべてのデータセットに対して，最適にフィットする関数を求められるとは限らない，

この問題は，回帰問題にも分類問題にも起こり得る．

![clipboard.png](inkdrop://file:BJmCzzLRz)
仮説関数をプロットすることは，次数を決める一つの方法になり得るが，

現実的には，3つ以上のフィーチャーを扱うことが多いので，

そもそもグラフとして表現し，それを評価して次数を決めることすら難しい．

![clipboard.png](inkdrop://file:HkiHPfUAG)

そのためには，以下のような手段がある．

- フィーチャーの数を減らす
  - 人力でフィーチャーを選択する
  - モデル選択アルゴリズム(コースの後半

```
しかし，フィーチャーの数を減らすことは，与えられた情報を捨てることになるので，

例えば，全てのフィーチャーが家の価格を推定するのに有用だったとすれば，そのフィーチャーは捨て去るべきではない．
```

- 正規化を行う
  - 全てのフィーチャーを維持するが，パラメータθjの倍率を下げる．
  - ただし，全てのフィーチャーがyを予測するために，それぞれ少しずつ貢献している場合に有用．


## 目的関数
正規化を行うために，新しく目的関数を定義する．

![clipboard.png](inkdrop://file:ryce6MLAM)

上では，既存の(回帰問題でも分類問題に対しても有用な)目的関数に対して，新しく項を追加した．

この目的関数を最小化するためには，θ3とθ4を0に近づける必要がある．

したがって，算出される仮説関数は，θ0，θ1，θ2，θ3，θ4の項を考慮した

2次関数のような形になる．(がもちろんθ3とθ4は捨てずにある程度考慮してある)

これで，全てのフィーチャーを用いつつ，オーバーフィッティングを避けるようにして，

仮説関数を立てることが出来る．

これが正規化の基本的なアイディア．(θに対してペナルティを与える)

しかし，それぞれのθに対して，どれだけペナルティを与えれば良いのか分からない．

例えば，家の価格を予測する仮説関数を考えるとして，100個位のフィーチャーがあるとすると，

それぞれのフィーチャーがどれくらい仮説関数に対して有用なのか分からない．

(上の例ではθ3，θ4はあまり仮説関数に対して有用な情報ではない)

なので，とりあえず全てのθに対してペナルティをかけてみる．

以下が，上記の内容を考慮した仮説関数の定義である．

![clipboard.png](inkdrop://file:ByQjJQ8Af)

![clipboard.png](inkdrop://file:rkyyQm80M)

従来の仮説関数の末尾に，正規化項を加えた．

i = 1から始まっているのは，気にしなくていい．

ラムダは正規化パラメータ．

以下は，ラムダがとても大きな場合にどうなるかの問題．

![clipboard.png](inkdrop://file:SJ0U-Q8CG)
- ✗ ラムダが大きくても問題ない
- ✗ オーバーフィッティングする
- ✔ アンダーフィッティングする
- ✗ 最急降下法は収束しない

ラムダがとても大きいと，パラメータθは0に限りなく近づくので，

hθ(x) = θ0 とみなすことが出来る．

![clipboard.png](inkdrop://file:Bkx4MQLAM)

ラムダがあまりにも大きいと，仮説関数が，上の図のようにデータセットに対して

良くフィットしない．

最適なラムダを選ぶアルゴリズムは，マルチセレクションのコースで説明する．



## 正規化された線形回帰

前回，目的関数に正規化項を導入した，

今回は，その目的関数を線形回帰に適用する．

![clipboard.png](inkdrop://file:SkfomX8Az)

以前は，正規化項を適用する前の状態で，最急降下法を導入する方法を紹介した．

![clipboard.png](inkdrop://file:rkv9VmLRz)

これに対して，正規化項を導入すると以下のようになる．

![clipboard.png](inkdrop://file:Bk-A4XLRz)

さらに，θjに関する項をまとめると以下のようになる，

![clipboard.png](inkdrop://file:SyEk8XI0f)

以下は，正規化項の特性に関する問題．

![clipboard.png](inkdrop://file:S1a-B78Az)


すわなち，正規化項は1より小さい値になる．例えば0.99とか．


最急降下法は，線形回帰のモデルにフィッティングする2つのうちの一つに過ぎない．

もう一つの方法として，正則化があった．

次に，正則化に対して正規化項を導入してみる．

正規化項導入魔炎の正則化は以下のようであった．

![clipboard.png](inkdrop://file:SJkVDX80f)

正規化項を導入すると以下のようになる．

![clipboard.png](inkdrop://file:B1FuDm8CM)

正規方程式の時にも上がった問題だが，非可逆の問題について．

フィーチャーの数よりも少ないデータセットの場合に，

上のX転置Xは，非可逆，あるいは特異行列となり，逆行列を求めることができなかった．

Octaveでは，pinv関数で擬似逆行列を生成することも出来るが，良い仮説関数ができるとは限らない．

他のライブラリで，非可逆な行列に対して逆行列を求めようとすると，うまくいかない．

しかし，ラッキーなことに，正規化を行うことで，このような問題にも対応できる．

ラムダが0より大きい場合に，以下を満たす，

![clipboard.png](inkdrop://file:S1mTuQLRf)



## 正規化されたロジスティック回帰

前回は回帰問題を解くために，最急降下法と正則化にたいして，正規化項を適用して，

オーバーフィッティングを発生させずに，仮説関数を求める方法を理解した．

今回は，分類問題におけるオーバーフィッティングを解消するために，

ロジスティック回帰に対して正規化を適用してみる．

ロジスティック回帰において，フィーチャーの数が多くなるとオーバーフィッティングしがちである．

以下は，これまで勉強してきたロジスティック回帰の目的関数の定義である，

![clipboard.png](inkdrop://file:B1KE97U0M)
これに，正規化を施すと以下のようになる．

![clipboard.png](inkdrop://file:BkZ_oQIRG)
 目的関数が定まったので，これを使って最急降下法を適用してみると以下のようになる．
 
![clipboard.png](inkdrop://file:r1FKhQ8Rf)

回帰問題を正規化を適用した最急降下法で解く場合と同じ数式だが，

仮説関数はシグモイド関数なので，ここだけ注意．全くの別物．

以下は，正規化されたロジスティック回帰を使用する際に，

最急降下法がちゃんと動いている方法を考える問題．

![clipboard.png](inkdrop://file:rk5raXIRM)
関数をプロットして，ちゃんと減少しているか確認する．

以下は，正規化されたロジスティック回帰をOctaveを使って最適化されたθを求める例．

![clipboard.png](inkdrop://file:HJfDRmUCf)


